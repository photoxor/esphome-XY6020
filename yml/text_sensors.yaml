text_sensor:
  - platform: modbus_controller
    #modbus_controller_id: mod_bus_controller
    bitmask: 0
    register_type: holding
    address: 0x10
    raw_encode: HEXBYTES
    name: "XL6020 Protect Status"
    entity_category: DIAGNOSTIC 
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0000: return std::string("Normal");
        case 0001: return std::string("Over Voltage");
        case 0002: return std::string("Over Current");
        case 0003: return std::string("OPP");
        case 0004: return std::string("LVP");
        case 0005: return std::string("OAH");
        case 0006: return std::string("OHP");
        case 0007: return std::string("OTP");
        default: return std::string("Unknown");
      }
      return x;
  
  

#      } else if (id(protectsensor).state == 8) {
#        return {"${OEP}"};
#      } else if (id(protectsensor).state == 9) {
#        return {"${OWH}"};
#      } else if (id(protectsensor).state == 10) {
#        return {"${ICP}"};



  - platform: modbus_controller
    #modbus_controller_id: mod_bus_controller
    bitmask: 0
    register_type: holding
    address: 0x11
    raw_encode: HEXBYTES
    name: "XL6020 CV-CC"
    entity_category: DIAGNOSTIC 
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0000: return std::string("CV");
        case 0001: return std::string("CC");
        default: return std::string("Unknown");
      }
      return x;


  - platform: modbus_controller
   #modbus_controller_id: mod_bus_controller
    bitmask: 0
    register_type: holding
    address: 0x12
    raw_encode: HEXBYTES
    name: "XL6020 Power Switch"
    entity_category: DIAGNOSTIC 
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0000: return std::string("OFF");
        case 0001: return std::string("On");
        default: return std::string("Unknown");
      }
      return x;
    
  - platform: modbus_controller
    #modbus_controller_id: mod_bus_controller
    bitmask: 0
    register_type: holding
    address: 0x0F
    raw_encode: HEXBYTES
    name: "XL6020 Key Lock"
    entity_category: DIAGNOSTIC 
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0000: return std::string("unlock");
        case 0001: return std::string("locked");
        default: return std::string("Unknown");
      }
      return x;
 

  # - platform: template
  #   name: "XL6020 Turn On Time"
  #   entity_category: DIAGNOSTIC 
  #   lambda: |-
  #     char buffer[16];
  #     std::string ton_time;
  #     std::snprintf(buffer, 16, "%02d:%02d:%02d" , (int)id(turnon_hours).state, (int)id(turnon_minutes).state, (int)id(turnon_seconds).state);
  #     ton_time = buffer;
  #     return {ton_time};
  #   update_interval: 1s
